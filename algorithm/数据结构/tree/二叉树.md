# 数据基础

```bash
# 二叉树
- 每个节点，最多只存在两个子节点

# 满二叉树
- 每个节点都有两个叶子节点

# 完全二叉树
- 其余层必须填满，最后一层不一定
- 最后一层：必须从左向右填充

# N叉树
- 一个节点可能有多个孩子
```

```java
package com.erick.d01;

public class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
```

```java
package com.erick.d01;

import java.util.List;

public class Node {
    int val;
    List<Node> children;

    public Node(int val, List<Node> children) {
        this.val = val;
        this.children = children;
    }
}
```

## 广度优先-BFS

- Bredth First Search：处理完当前层的节点的值之后，再去处理下一层的结果

### 😎[102.层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- 每层从左到右，从顶到底

#### 队列 + 迭代

```bash
# 队列思路
- 根节点入队
- 头弹出，处理当前节点，然后将当前节点的左右孩子依次入队
- 直到队列为空
```

![image-20250526101134528](https://skillset.oss-cn-shanghai.aliyuncs.com/image-20250526101134528.png)